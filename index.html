<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PrismatiCore</title>
    <style>
        :root { --bg: #f8f9fa; --card: #ffffff; --accent: #4a90e2; }
        body { 
            margin: 0; font-family: -apple-system, system-ui, sans-serif; 
            background: var(--bg); display: flex; flex-direction: column; height: 100vh; overflow: hidden; 
        }
        #header { 
            padding: 15px; background: var(--card); display: flex; justify-content: space-around; 
            align-items: center; border-bottom: 1px solid #ddd; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        select { padding: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: 14px; }
        
        button#hintBtn { 
            padding: 8px 16px; border-radius: 20px; border: none; 
            background: var(--accent); color: white; font-weight: bold; cursor: pointer;
        }
        button#hintBtn:disabled { background: #ccc; }

        #canvas-container { 
            flex: 1; display: flex; align-items: center; justify-content: center; 
            overflow: hidden; position: relative; padding: 10px;
        }
        canvas { 
            background: #fff; box-shadow: 0 10px 30px rgba(0,0,0,0.1); 
            max-width: 100%; max-height: 100%; object-fit: contain; image-rendering: pixelated;
        }

        #palette { 
            display: flex; gap: 12px; padding: 20px; background: var(--card); 
            border-top: 1px solid #ddd; overflow-x: auto; min-height: 60px; justify-content: center;
        }
        .swatch { 
            min-width: 50px; height: 50px; border-radius: 50%; 
            border: 4px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: 0.2s;
        }
        .swatch.active { border-color: #333; transform: translateY(-5px); }
    </style>
</head>
<body>

<div id="header">
    <select id="imageSelector"><option value="">-- Choose Image --</option></select>
    <button id="hintBtn" onclick="giveHint()" disabled>Need a Hint?</button>
</div>

<div id="status-bar" style="text-align:center; font-size:12px; padding:5px; color:#888;"></div>

<div id="canvas-container">
    <canvas id="gameCanvas"></canvas>
</div>

<div id="palette"></div>

<script>
    const selector = document.getElementById('imageSelector');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const paletteDiv = document.getElementById('palette');
    const hintBtn = document.getElementById('hintBtn');

    let gameData = null;
    let activeColorIdx = null;
    let paintedShapes = new Set();
    let hintShapeId = null;

    fetch('image_data/manifest.json').then(res => res.json()).then(files => {
        files.forEach(file => {
            const opt = document.createElement('option');
            opt.value = file;
            opt.textContent = file.replace('_tapdata.json', '').replace(/_/g, ' ');
            selector.appendChild(opt);
        });
    });

    selector.onchange = async (e) => {
        if (!e.target.value) return;
        const res = await fetch(`image_data/${e.target.value}`);
        gameData = await res.json();
        paintedShapes.clear();
        activeColorIdx = null;
        hintBtn.disabled = true;
        setupGame();
    };

    function setupGame() {
        canvas.width = gameData.width;
        canvas.height = gameData.height;
        renderPalette();
        render();
    }

    function renderPalette() {
        paletteDiv.innerHTML = '';
        gameData.palette.forEach((rgb, idx) => {
            const colorIdx = idx + 1;
            
            // Check if this color is complete
            const totalOfColor = gameData.shapeToColor.filter(c => c === colorIdx).length;
            let foundOfColor = 0;
            gameData.shapeToColor.forEach((c, i) => {
                if (c === colorIdx && paintedShapes.has(i + 1)) foundOfColor++;
            });

            // Only show swatch if not finished
            if (foundOfColor < totalOfColor) {
                const swatch = document.createElement('div');
                swatch.className = 'swatch' + (activeColorIdx === colorIdx ? ' active' : '');
                swatch.style.backgroundColor = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                swatch.onclick = () => {
                    activeColorIdx = colorIdx;
                    hintBtn.disabled = false;
                    renderPalette();
                    render();
                };
                paletteDiv.appendChild(swatch);
            }
        });
        
        if (paletteDiv.innerHTML === '' && gameData) {
            document.getElementById('status-bar').innerText = "Masterpiece Finished!";
        }
    }

    function render() {
        if (!gameData) return;
        const imgData = ctx.createImageData(gameData.width, gameData.height);
        const { map, shapeToColor, palette, width } = gameData;

        for (let i = 0; i < map.length; i++) {
            const sid = map[i];
            const cid = shapeToColor[sid - 1];
            let r, g, b;

            if (sid === 0) { [r, g, b] = [255, 255, 255]; }
            else if (paintedShapes.has(sid)) { [r, g, b] = palette[cid - 1]; }
            else if (sid === hintShapeId) { [r, g, b] = [255, 0, 0]; } // Hint Flash
            else if (activeColorIdx === cid) {
                const pat = (Math.floor((i%width)/8) + Math.floor((i/width)/8)) % 2 === 0;
                [r, g, b] = pat ? [255, 255, 255] : [230, 230, 230];
            } else { [r, g, b] = [245, 245, 245]; }

            const p = i * 4;
            imgData.data[p]=r; imgData.data[p+1]=g; imgData.data[p+2]=b; imgData.data[p+3]=255;
        }
        ctx.putImageData(imgData, 0, 0);
    }

    function giveHint() {
        if (!activeColorIdx) return;
        // Find an unpainted shape of the active color
        const unpainted = [];
        gameData.shapeToColor.forEach((cid, idx) => {
            const sid = idx + 1;
            if (cid === activeColorIdx && !paintedShapes.has(sid)) unpainted.push(sid);
        });

        if (unpainted.length > 0) {
            hintShapeId = unpainted[Math.floor(Math.random() * unpainted.length)];
            render();
            setTimeout(() => { hintShapeId = null; render(); }, 600);
        }
    }

    canvas.onclick = (e) => {
        if (!gameData || !activeColorIdx) return;
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width));
        const y = Math.floor((e.clientY - rect.top) * (canvas.height / rect.height));

        const sid = gameData.map[y * gameData.width + x];
        if (sid > 0 && gameData.shapeToColor[sid - 1] === activeColorIdx) {
            paintedShapes.add(sid);
            renderPalette();
            render();
        }
    };
</script>
</body>
</html>