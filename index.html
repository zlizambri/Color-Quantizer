<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PrismatiCore Basic</title>
    <style>
        body { 
            margin: 0; font-family: sans-serif; background: #f0f0f0; 
            display: flex; flex-direction: column; height: 100vh; 
        }
        #header { padding: 15px; background: #fff; text-align: center; border-bottom: 1px solid #ccc; }
        #canvas-container { 
            flex: 1; display: flex; align-items: center; justify-content: center; 
            overflow: auto; padding: 20px;
        }
        canvas { 
            background: #fff; box-shadow: 0 0 20px rgba(0,0,0,0.2); 
            cursor: pointer; max-width: 100%; height: auto;
        }
        #palette { 
            display: flex; gap: 10px; padding: 20px; background: #fff; 
            border-top: 1px solid #ccc; overflow-x: auto; 
        }
        .swatch { 
            min-width: 50px; height: 50px; border-radius: 25px; 
            border: 3px solid #eee; cursor: pointer; transition: 0.2s;
        }
        .swatch.active { border-color: #333; transform: scale(1.1); }
    </style>
</head>
<body>

<div id="header">
    <select id="imageSelector">
        <option value="">-- Select an Image --</option>
    </select>
</div>

<div id="canvas-container">
    <canvas id="gameCanvas"></canvas>
</div>

<div id="palette"></div>

<script>
    const selector = document.getElementById('imageSelector');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const paletteDiv = document.getElementById('palette');

    let gameData = null;
    let activeColorIdx = null; // 1-indexed
    let paintedShapes = new Set(); // Stores unique shape IDs

    // 1. Load the list of images
    fetch('image_data/manifest.json')
        .then(res => res.json())
        .then(files => {
            files.forEach(file => {
                const opt = document.createElement('option');
                opt.value = file;
                opt.textContent = file.replace('_tapdata.json', '').replace(/_/g, ' ');
                selector.appendChild(opt);
            });
        });

    // 2. Load the specific JSON when selected
    selector.onchange = async (e) => {
        if (!e.target.value) return;
        const res = await fetch(`image_data/${e.target.value}`);
        gameData = await res.json();
        
        paintedShapes.clear();
        activeColorIdx = null;
        
        setupGame();
    };

    function setupGame() {
        canvas.width = gameData.width;
        canvas.height = gameData.height;

        // Build Palette
        paletteDiv.innerHTML = '';
        gameData.palette.forEach((rgb, idx) => {
            const swatch = document.createElement('div');
            swatch.className = 'swatch';
            swatch.style.backgroundColor = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
            swatch.onclick = () => {
                document.querySelectorAll('.swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                activeColorIdx = idx + 1;
                render();
            };
            paletteDiv.appendChild(swatch);
        });

        render();
    }

    function render() {
        if (!gameData) return;
        const imgData = ctx.createImageData(gameData.width, gameData.height);
        const map = gameData.map;
        const stc = gameData.shapeToColor;
        const palette = gameData.palette;

        for (let i = 0; i < map.length; i++) {
            const shapeId = map[i];
            const colorIdxOfShape = stc[shapeId - 1];
            let r, g, b;

            if (shapeId === 0) {
                r = g = b = 255; // White background
            } else if (paintedShapes.has(shapeId)) {
                // Already painted
                [r, g, b] = palette[colorIdxOfShape - 1];
            } else if (activeColorIdx === colorIdxOfShape) {
                // Highlighted for current selection
                const x = i % gameData.width;
                const y = Math.floor(i / gameData.width);
                const pattern = (Math.floor(x/10) + Math.floor(y/10)) % 2 === 0;
                r = g = b = pattern ? 255 : 220;
            } else {
                // Unpainted / Not active
                r = g = b = 245;
            }

            const p = i * 4;
            imgData.data[p] = r; 
            imgData.data[p+1] = g; 
            imgData.data[p+2] = b; 
            imgData.data[p+3] = 255;
        }
        ctx.putImageData(imgData, 0, 0);
    }

    // 3. Handle Clicking/Tapping
    canvas.onclick = (e) => {
        if (!gameData || !activeColorIdx) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const x = Math.floor((e.clientX - rect.left) * scaleX);
        const y = Math.floor((e.clientY - rect.top) * scaleY);

        if (x >= 0 && x < gameData.width && y >= 0 && y < gameData.height) {
            const clickedShapeId = gameData.map[y * gameData.width + x];
            if (clickedShapeId > 0) {
                const colorOfClickedShape = gameData.shapeToColor[clickedShapeId - 1];
                
                // Only fill if it matches the active color
                if (colorOfClickedShape === activeColorIdx) {
                    paintedShapes.add(clickedShapeId);
                    render();
                }
            }
        }
    };
</script>

</body>
</html>