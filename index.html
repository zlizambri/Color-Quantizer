<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PrismatiCore Master</title>
    <style>
        :root { --bg: #f0f2f5; --card: #ffffff; --accent: #007aff; --danger: #ff3b30; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body { 
            margin: 0; font-family: -apple-system, system-ui, sans-serif; 
            background: var(--bg); display: flex; flex-direction: column; 
            height: 100dvh; width: 100vw; overflow: hidden; position: fixed;
        }
        
        #header { 
            height: auto; min-height: 90px; padding: 10px 15px; background: var(--card); 
            display: flex; flex-direction: column; gap: 8px;
            border-bottom: 1px solid #ddd; z-index: 100; flex-shrink: 0;
            padding-top: env(safe-area-inset-top);
        }

        .controls-row { display: flex; justify-content: space-between; align-items: center; width: 100%; gap: 10px; }
        
        #viewport { 
            flex: 1; position: relative; overflow: hidden; 
            background: #cbd5e0; display: flex; align-items: center; justify-content: center;
        }

        canvas { 
            background: #fff; box-shadow: 0 5px 25px rgba(0,0,0,0.25); 
            transform-origin: center; touch-action: none; 
            image-rendering: pixelated; display: block;
        }

        #palette { 
            height: 130px; display: flex; gap: 14px; padding: 15px; 
            background: var(--card); border-top: 1px solid #ddd; 
            overflow-x: auto; flex-shrink: 0; align-items: center; 
            justify-content: flex-start; z-index: 100;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
        }
        
        .swatch-container { position: relative; flex-shrink: 0; text-align: center; }
        .swatch { 
            min-width: 65px; height: 65px; border-radius: 50%; 
            border: 4px solid #fff; box-shadow: 0 3px 8px rgba(0,0,0,0.15); 
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 20px; color: white; text-shadow: 0 1px 4px rgba(0,0,0,0.6);
            transition: transform 0.2s;
        }
        .swatch.active { border-color: #333; transform: scale(1.15) translateY(-8px); box-shadow: 0 8px 15px rgba(0,0,0,0.2); }

        .slider-box { display: flex; align-items: center; gap: 8px; font-size: 13px; font-weight: bold; color: #444; }
        input[type=range] { width: 90px; }

        .btn-group { display: flex; gap: 8px; }
        button { 
            padding: 8px 14px; border-radius: 20px; border: none; 
            font-weight: 700; font-size: 13px; cursor: pointer;
        }
        #hintBtn { background: var(--accent); color: white; }
        #resetBtn { background: #eee; color: #666; font-size: 18px; padding: 4px 12px; }
        button:disabled { background: #ccc !important; opacity: 0.5; }

        select { height: 38px; border-radius: 8px; border: 1px solid #ccc; font-size: 15px; background: #fff; flex: 1; }
    </style>
</head>
<body>

<div id="header">
    <div class="controls-row">
        <select id="imageSelector"><option value="">-- Choose Image --</option></select>
        <div class="btn-group">
            <button id="resetBtn" onclick="resetProgress()" title="Restart Puzzle">â†º</button>
            <button id="hintBtn" onclick="giveHint()" disabled>Hint</button>
        </div>
    </div>
    <div class="controls-row">
        <div class="slider-box">
            <span>Tap Size:</span>
            <input type="range" id="radiusSlider" min="1" max="60" value="20">
        </div>
        <div id="status-bar" style="font-size: 12px; font-weight:600; color: #666;">Ready!</div>
    </div>
</div>

<div id="viewport">
    <canvas id="gameCanvas"></canvas>
</div>

<div id="palette"></div>

<script>
    const selector = document.getElementById('imageSelector');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const paletteDiv = document.getElementById('palette');
    const hintBtn = document.getElementById('hintBtn');
    const radiusSlider = document.getElementById('radiusSlider');
    const statusBar = document.getElementById('status-bar');

    let gameData = null;
    let activeColorIdx = null;
    let paintedShapes = new Set();
    let hintShapeId = null;
    let scale = 1, lastScale = 1, posX = 0, posY = 0, lastPosX = 0, lastPosY = 0, startDist = 0;

    // Load Puzzle List
    document.addEventListener('DOMContentLoaded', () => {
        fetch('image_data/manifest.json')
            .then(res => res.json())
            .then(files => {
                files.forEach(file => {
                    const opt = document.createElement('option');
                    opt.value = file;
                    opt.textContent = file.replace('_tapdata.json', '').replace(/_/g, ' ');
                    selector.appendChild(opt);
                });
            });
    });

    selector.onchange = async (e) => {
        if (!e.target.value) return;
        const filename = e.target.value;
        const res = await fetch(`image_data/${filename}`);
        gameData = await res.json();
        
        // --- LOAD PROGRESS ---
        const saved = localStorage.getItem('prismasave_' + filename);
        if (saved) {
            paintedShapes = new Set(JSON.parse(saved));
            statusBar.innerText = "Resumed progress!";
        } else {
            paintedShapes.clear();
            statusBar.innerText = "Starting new!";
        }
        
        activeColorIdx = null;
        hintBtn.disabled = true;
        
        canvas.width = gameData.width;
        canvas.height = gameData.height;
        const vRect = document.getElementById('viewport').getBoundingClientRect();
        scale = Math.min(vRect.width / canvas.width, vRect.height / canvas.height) * 0.85;
        posX = 0; posY = 0;
        
        updateTransform();
        renderPalette();
        render();
    };

    function saveProgress() {
        if (!gameData) return;
        localStorage.setItem('prismasave_' + selector.value, JSON.stringify([...paintedShapes]));
    }

    function resetProgress() {
        if (!gameData) return;
        if (confirm("Start this masterpiece over from the beginning?")) {
            paintedShapes.clear();
            localStorage.removeItem('prismasave_' + selector.value);
            activeColorIdx = null;
            hintBtn.disabled = true;
            renderPalette();
            render();
            statusBar.innerText = "Puzzle Reset.";
        }
    }

    function renderPalette() {
        paletteDiv.innerHTML = '';
        if (!gameData) return;
        gameData.palette.forEach((rgb, idx) => {
            const colorIdx = idx + 1;
            const total = gameData.shapeToColor.filter(c => c === colorIdx).length;
            let found = 0;
            gameData.shapeToColor.forEach((c, i) => { if (c === colorIdx && paintedShapes.has(i + 1)) found++; });

            if (found < total) {
                const container = document.createElement('div');
                container.className = 'swatch-container';
                const swatch = document.createElement('div');
                swatch.className = 'swatch' + (activeColorIdx === colorIdx ? ' active' : '');
                swatch.style.backgroundColor = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                swatch.innerText = colorIdx;
                swatch.onclick = () => { activeColorIdx = colorIdx; hintBtn.disabled = false; updateStatus(); renderPalette(); render(); };
                container.appendChild(swatch);
                paletteDiv.appendChild(container);
            }
        });
        if (paletteDiv.innerHTML === "" && paintedShapes.size > 0) {
            statusBar.innerText = "ðŸ† 100% COMPLETE! ðŸ†";
        }
    }

    function updateStatus() {
        if (!gameData || !activeColorIdx) return;
        const totalOfColor = gameData.shapeToColor.filter(c => c === activeColorIdx).length;
        let foundOfColor = 0;
        gameData.shapeToColor.forEach((c, i) => { if (c === activeColorIdx && paintedShapes.has(i + 1)) foundOfColor++; });
        statusBar.innerText = `${totalOfColor - foundOfColor} left for color #${activeColorIdx}`;
    }

    function render() {
        if (!gameData) return;
        const imgData = ctx.createImageData(gameData.width, gameData.height);
        const { map, shapeToColor, palette, width } = gameData;
        for (let i = 0; i < map.length; i++) {
            const sid = map[i];
            const cid = shapeToColor[sid - 1];
            let r, g, b;
            
            if (sid === 0) [r, g, b] = [255, 255, 255];
            else if (paintedShapes.has(sid)) [r, g, b] = palette[cid - 1];
            else if (sid === hintShapeId) [r, g, b] = [255, 0, 0];
            else if (activeColorIdx === cid) {
                const x = i % width; const y = Math.floor(i / width);
                const pat = (Math.floor(x/10) + Math.floor(y/10)) % 2 === 0;
                [r, g, b] = pat ? [255, 255, 255] : [100, 116, 139]; 
            } else [r, g, b] = [240, 240, 240];
            
            const p = i * 4; imgData.data[p]=r; imgData.data[p+1]=g; imgData.data[p+2]=b; imgData.data[p+3]=255;
        }
        ctx.putImageData(imgData, 0, 0);
    }

    function updateTransform() { canvas.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`; }

    // Touch/Interaction
    let isMoving = false, touches = [], startX, startY;
    canvas.addEventListener('pointerdown', (e) => {
        touches.push(e);
        if (touches.length === 1) {
            isMoving = false; lastPosX = posX; lastPosY = posY; startX = e.clientX; startY = e.clientY;
        } else if (touches.length === 2) {
            startDist = Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
            lastScale = scale;
        }
    });
    window.addEventListener('pointermove', (e) => {
        const idx = touches.findIndex(t => t.pointerId === e.pointerId);
        if (idx > -1) touches[idx] = e;
        if (touches.length === 1) {
            const dx = e.clientX - startX, dy = e.clientY - startY;
            if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                isMoving = true; posX = lastPosX + dx; posY = lastPosY + dy; updateTransform();
            }
        } else if (touches.length === 2) {
            isMoving = true;
            const newDist = Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
            scale = lastScale * (newDist / startDist); updateTransform();
        }
    });
    window.addEventListener('pointerup', (e) => {
        if (touches.length === 1 && !isMoving) handleTap(touches[0]);
        touches = touches.filter(t => t.pointerId !== e.pointerId);
    });

    function handleTap(e) {
        if (!gameData || !activeColorIdx) return;
        const rect = canvas.getBoundingClientRect();
        const clickX = (e.clientX - rect.left) * (canvas.width / rect.width);
        const clickY = (e.clientY - rect.top) * (canvas.height / rect.height);
        const radius = parseInt(radiusSlider.value);
        let foundAny = false;

        const sX = Math.max(0, Math.floor(clickX - radius)), eX = Math.min(gameData.width - 1, Math.ceil(clickX + radius));
        const sY = Math.max(0, Math.floor(clickY - radius)), eY = Math.min(gameData.height - 1, Math.ceil(clickY + radius));

        for (let y = sY; y <= eY; y++) {
            for (let x = sX; x <= eX; x++) {
                if (Math.sqrt((x - clickX)**2 + (y - clickY)**2) <= radius) {
                    const sid = gameData.map[y * gameData.width + x];
                    if (sid > 0 && gameData.shapeToColor[sid - 1] === activeColorIdx && !paintedShapes.has(sid)) {
                        paintedShapes.add(sid); foundAny = true;
                    }
                }
            }
        }
        if (foundAny) { 
            saveProgress(); // AUTO-SAVE ON TAP
            updateStatus(); 
            renderPalette(); 
            render(); 
        }
    }

    function giveHint() {
        if (!activeColorIdx) return;
        const unpainted = [];
        gameData.shapeToColor.forEach((cid, idx) => { if (cid === activeColorIdx && !paintedShapes.has(idx+1)) unpainted.push(idx+1); });
        if (unpainted.length > 0) {
            hintShapeId = unpainted[Math.floor(Math.random() * unpainted.length)];
            render(); setTimeout(() => { hintShapeId = null; render(); }, 800);
        }
    }
</script>
</body>
</html>